<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Dragonwood</title>
<style>
body { font-family: Georgia, 'Times New Roman', serif; }

:root {
  --gold:      #d4a017;
  --gold-lt:   #f0c84a;
  --gold-dk:   #8a6510;
  --bg:        #0b1a0b;
  --bg2:       #132213;
  --parch:     #f0e2c0;
  --parch-dk:  #c8a870;
  --grn-bdr:   #3a8a3a;
  --pur-bdr:   #8b2fc9;
}

*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
html, body { height: 100%; background: var(--bg); color: var(--parch); }

.screen { display: none; min-height: 100vh; }
.screen.active { display: flex; }

/* ‚ïê‚ïê‚ïê SETUP ‚ïê‚ïê‚ïê */
#setup {
  flex-direction: column; align-items: center; justify-content: center;
  padding: 40px 20px;
  background: radial-gradient(ellipse at 50% 30%, #1a3a1a 0%, #0b1a0b 70%);
}
.logo { text-align: center; margin-bottom: 36px; }
.logo-icon { font-size: 68px; display: block; margin-bottom: 8px; }
.logo h1 { font-size: clamp(34px,8vw,70px); letter-spacing:.15em; color:var(--gold-lt); text-shadow:0 0 28px rgba(212,160,23,.4),0 2px 0 #000; font-variant:small-caps; }
.logo p  { font-size:13px; letter-spacing:.35em; color:var(--gold-dk); text-transform:uppercase; margin-top:5px; }

.setup-box {
  background: linear-gradient(170deg,#1c3520,#0e1e10);
  border:1px solid var(--gold-dk); border-radius:16px; padding:34px 42px;
  width:100%; max-width:500px; box-shadow:0 20px 60px rgba(0,0,0,.6);
}
.setup-box h2 { font-size:10px; letter-spacing:.3em; color:var(--gold-dk); text-transform:uppercase; margin-bottom:22px; text-align:center; }
.field-lbl { display:block; font-size:10px; letter-spacing:.2em; color:var(--gold-dk); text-transform:uppercase; margin-bottom:7px; }
.count-row { display:flex; align-items:center; gap:14px; margin-bottom:24px; }
.cnt-btn { width:38px;height:38px;border-radius:50%;border:1px solid var(--gold-dk);background:rgba(212,160,23,.08);color:var(--gold-lt);font-size:22px;cursor:pointer;transition:background .15s; }
.cnt-btn:hover { background:rgba(212,160,23,.22);border-color:var(--gold); }
#cnt-display { font-size:28px; color:var(--gold-lt); min-width:36px; text-align:center; }
.cnt-label { color:var(--parch-dk); font-size:14px; }

.name-fields { display:flex; flex-direction:column; gap:10px; margin-bottom:26px; }
.name-row { display:flex; align-items:center; gap:10px; }
.name-row label { font-size:11px; color:var(--gold-dk); letter-spacing:.1em; width:56px; text-align:right; flex-shrink:0; }
.name-input { flex:1; background:rgba(0,0,0,.35); border:1px solid rgba(212,160,23,.25); border-radius:8px; color:var(--parch); font-family:inherit; font-size:15px; padding:9px 13px; outline:none; transition:border-color .2s; }
.name-input:focus { border-color:var(--gold); }
.ai-toggle {
  display:flex; align-items:center; gap:6px; cursor:pointer;
  background:rgba(138,47,201,.12); border:1px solid rgba(138,47,201,.3);
  border-radius:8px; padding:6px 10px; font-size:12px; color:#ce93d8;
  transition:all .2s; white-space:nowrap; flex-shrink:0;
}
.ai-toggle:hover { background:rgba(138,47,201,.25); border-color:#8b2fc9; }
.ai-toggle input { display:none; }
.ai-toggle.checked { background:rgba(138,47,201,.35); border-color:#8b2fc9; color:#e1bee7; }
.ai-toggle .ai-dot { width:10px;height:10px;border-radius:50%;background:#9c4dcc;transition:background .2s; }
.ai-toggle.checked .ai-dot { background:#ce93d8; box-shadow:0 0 6px #9c4dcc; }

.start-btn { width:100%;padding:15px;background:linear-gradient(180deg,var(--gold-lt),var(--gold) 55%,#906000);border:none;border-radius:10px;color:#1a0e00;font-family:inherit;font-size:15px;font-weight:bold;letter-spacing:.15em;cursor:pointer;text-transform:uppercase;transition:filter .2s,transform .15s;box-shadow:0 4px 18px rgba(212,160,23,.3); }
.start-btn:hover { filter:brightness(1.12); transform:translateY(-2px); }
.start-btn:active { transform:translateY(0); }

/* ‚ïê‚ïê‚ïê GAME ‚ïê‚ïê‚ïê */
#game { flex-direction:column; background:var(--bg); background-image:radial-gradient(ellipse at 20% 60%,rgba(20,50,20,.35) 0%,transparent 55%),radial-gradient(ellipse at 80% 10%,rgba(10,25,10,.5) 0%,transparent 50%); }

.topbar { background:rgba(5,10,5,.97); border-bottom:1px solid rgba(212,160,23,.2); padding:8px 18px; display:flex; align-items:center; gap:16px; flex-wrap:wrap; position:sticky; top:0; z-index:50; }
.tb-title { font-size:16px; color:var(--gold); letter-spacing:.1em; font-variant:small-caps; }
.tb-turn  { flex:1; font-size:13px; color:#70e870; letter-spacing:.08em; }
.tb-turn.ai-turn { color:#ce93d8; }
.tb-turn.wound-turn { color:#ff8888; }
.tb-decks { font-size:11px; color:var(--gold-dk); letter-spacing:.1em; }
.score-chips { display:flex; gap:8px; flex-wrap:wrap; }
.chip { background:rgba(212,160,23,.08); border:1px solid rgba(212,160,23,.2); border-radius:20px; padding:3px 11px; font-size:11px; color:var(--gold-lt); letter-spacing:.05em; }
.chip.active { background:rgba(212,160,23,.22); border-color:var(--gold); }
.chip.ai-chip { border-color:rgba(138,47,201,.4); }
.chip.ai-chip.active { background:rgba(138,47,201,.25); border-color:#8b2fc9; color:#ce93d8; }

.game-body { display:grid; grid-template-columns:1fr 255px; flex:1; overflow:hidden; }
.g-left  { padding:14px; display:flex; flex-direction:column; gap:12px; overflow-y:auto; }
.g-right { background:rgba(5,10,5,.75); border-left:1px solid rgba(212,160,23,.12); padding:12px; display:flex; flex-direction:column; gap:14px; overflow-y:auto; }

.sec-lbl { font-size:9px; letter-spacing:.3em; color:var(--gold-dk); text-transform:uppercase; display:flex; align-items:center; gap:8px; margin-bottom:8px; }
.sec-lbl::after { content:''; flex:1; height:1px; background:linear-gradient(to right,var(--gold-dk),transparent); }

/* ‚ïê‚ïê‚ïê DRAGONWOOD CARDS ‚ïê‚ïê‚ïê */
.landscape-row { display:flex; gap:10px; flex-wrap:wrap; }
.dw-card { width:138px; min-height:195px; border-radius:12px; padding:11px 10px; cursor:pointer; border-width:2px; border-style:solid; display:flex; flex-direction:column; gap:5px; flex-shrink:0; transition:transform .18s,box-shadow .18s; }
.dw-card:hover { transform:translateY(-5px); }
.dw-card.creature { background:linear-gradient(155deg,#1d5420,#0d2a0f); border-color:#3a8a3a; }
.dw-card.enhance  { background:linear-gradient(155deg,#3a1060,#180530); border-color:#8b2fc9; }
.dw-card.targeted { box-shadow:0 0 0 3px #ff4040,0 0 22px rgba(255,64,64,.45)!important; transform:translateY(-7px) scale(1.02); }
.dw-card.ai-eyeing{ box-shadow:0 0 0 2px #ce93d8,0 0 16px rgba(206,147,216,.3)!important; }

.c-badge { font-size:7px; letter-spacing:.18em; text-transform:uppercase; opacity:.7; margin-bottom:1px; }
.creature .c-badge { color:#80ff80; }
.enhance  .c-badge { color:#ce93d8; }
.c-name { font-size:11px; font-weight:bold; color:#fff; line-height:1.3; }
.c-vp { display:inline-flex; align-items:center; gap:3px; background:rgba(212,160,23,.15); border:1px solid var(--gold-dk); border-radius:14px; padding:1px 8px; font-size:11px; color:var(--gold-lt); width:fit-content; }
.c-effect { font-size:11px; color:#d0b0e0; line-height:1.4; flex:1; }
.c-perm   { font-size:8px; letter-spacing:.12em; color:#9c6aad; text-transform:uppercase; }
.c-divider { height:1px; background:rgba(255,255,255,.1); margin:3px 0; }
.attack-grid { display:flex; flex-direction:column; gap:4px; margin-top:auto; }
.atk-row { display:flex; align-items:center; justify-content:space-between; font-size:10px; letter-spacing:.05em; }
.atk-lbl { display:flex; align-items:center; gap:4px; }
.atk-strike .atk-lbl { color:#ef9a9a; }
.atk-stomp  .atk-lbl { color:#ffcc80; }
.atk-scream .atk-lbl { color:#90caf9; }
.atk-num { font-size:15px; font-weight:bold; color:#fff; }

/* ‚ïê‚ïê‚ïê ACTION PANEL ‚ïê‚ïê‚ïê */
.action-panel { background:rgba(5,14,5,.85); border:1px solid rgba(212,160,23,.18); border-radius:14px; padding:13px 15px; }
.sel-info { font-size:13px; color:var(--parch-dk); background:rgba(0,0,0,.3); border-radius:8px; padding:7px 10px; min-height:32px; margin-bottom:11px; line-height:1.5; }
.sel-info b { color:var(--gold-lt); }
.wound-banner { background:linear-gradient(135deg,#5a0000,#380000); border:2px solid #cc0000; border-radius:10px; padding:10px 14px; margin-bottom:10px; text-align:center; font-size:12px; color:#ff8888; letter-spacing:.08em; display:none; animation:pulseBorder 1s ease infinite; }
.wound-banner.show { display:block; }
.ai-thinking { background:linear-gradient(135deg,#280848,#160328); border:1px solid rgba(138,47,201,.4); border-radius:10px; padding:9px 13px; margin-bottom:10px; font-size:12px; color:#ce93d8; letter-spacing:.06em; display:none; text-align:center; }
.ai-thinking.show { display:block; }

.btn-row { display:flex; gap:7px; flex-wrap:wrap; }
.btn { flex:1; min-width:80px; padding:10px 6px; border:none; border-radius:10px; font-family:inherit; font-size:11px; font-weight:bold; letter-spacing:.04em; cursor:pointer; display:flex; flex-direction:column; align-items:center; gap:3px; line-height:1.2; transition:filter .15s,transform .15s; }
.btn .bi { font-size:18px; }
.btn .bs { font-size:8px; opacity:.7; }
.btn:hover:not(:disabled) { filter:brightness(1.2); transform:translateY(-2px); }
.btn:active:not(:disabled) { transform:translateY(0); }
.btn:disabled { opacity:.35; cursor:default; }
.btn-reload { background:linear-gradient(180deg,#455a64,#263238); color:#b0c0c8; }
.btn-strike { background:linear-gradient(180deg,#c62828,#7a0000); color:#ffcdd2; }
.btn-stomp  { background:linear-gradient(180deg,#6a1b9a,#36006a); color:#e1bee7; }
.btn-scream { background:linear-gradient(180deg,#1565c0,#0c2d6a); color:#bbdefb; }
.btn-clear  { background:linear-gradient(180deg,#424242,#1e1e1e); color:#9e9e9e; }

/* ‚ïê‚ïê‚ïê HAND ‚ïê‚ïê‚ïê */
.hand-lbl { font-size:9px; letter-spacing:.3em; color:var(--gold-dk); text-transform:uppercase; display:flex; align-items:center; gap:8px; margin-bottom:8px; }
.hand-lbl::after { content:''; flex:1; height:1px; background:linear-gradient(to right,var(--gold-dk),transparent); }
.hand-row { display:flex; gap:7px; flex-wrap:wrap; }
.adv-card { width:64px; height:90px; border-radius:10px; border:2px solid rgba(255,255,255,.15); display:flex; flex-direction:column; align-items:center; justify-content:center; cursor:pointer; transition:transform .15s,box-shadow .15s,border-color .15s; position:relative; overflow:hidden; user-select:none; }
.adv-card::after { content:''; position:absolute; inset:0; background:linear-gradient(135deg,rgba(255,255,255,.18) 0%,transparent 50%); pointer-events:none; }
.adv-card:hover:not(.in-wound) { transform:translateY(-9px); box-shadow:0 12px 28px rgba(0,0,0,.55); }
.adv-card.selected { border-color:var(--gold); box-shadow:0 0 0 3px var(--gold),0 0 18px rgba(212,160,23,.45); transform:translateY(-12px); }
.adv-card.in-wound:hover { border-color:#ff4444; box-shadow:0 0 0 3px #ff4444,0 0 18px rgba(255,68,68,.4); transform:translateY(-9px); }
.s0{background:linear-gradient(155deg,#4a0080,#280050);}
.s1{background:linear-gradient(155deg,#1a5c1a,#0a3010);}
.s2{background:linear-gradient(155deg,#8b1a1a,#500a0a);}
.s3{background:linear-gradient(155deg,#b87e0b,#7a5200);}
.s4{background:linear-gradient(155deg,#0d5078,#063050);}
.adv-num  { font-size:22px; font-weight:bold; color:#fff; text-shadow:0 1px 4px rgba(0,0,0,.5); }
.adv-suit { font-size:8px; color:rgba(255,255,255,.7); letter-spacing:.06em; text-align:center; margin-top:1px; }

/* ‚ïê‚ïê‚ïê RIGHT PANEL ‚ïê‚ïê‚ïê */
.rp-lbl { font-size:9px; letter-spacing:.28em; color:var(--gold-dk); text-transform:uppercase; margin-bottom:8px; display:flex; align-items:center; gap:8px; }
.rp-lbl::after { content:''; flex:1; height:1px; background:rgba(212,160,23,.18); }
.enh-owner { font-size:9px; color:var(--gold-dk); letter-spacing:.1em; text-transform:uppercase; margin:6px 0 4px; }
.enh-item { background:rgba(80,0,120,.28); border:1px solid rgba(139,47,201,.3); border-radius:8px; padding:6px 9px; margin-bottom:4px; }
.enh-item.used { opacity:.38; }
.enh-name { font-size:10px; color:#ce93d8; font-weight:bold; }
.enh-eff  { font-size:10px; color:#c0a0d0; }
.enh-tag  { font-size:8px; color:#9c6aad; letter-spacing:.1em; text-transform:uppercase; }
.no-enh   { font-size:11px; color:rgba(255,255,255,.2); font-style:italic; }
.enh-use-btn {
  display:inline-flex; align-items:center; gap:4px;
  margin-top:5px; padding:4px 9px;
  background:rgba(138,47,201,.2); border:1px solid rgba(138,47,201,.5);
  border-radius:6px; color:#ce93d8; font-size:10px; font-family:inherit;
  cursor:pointer; letter-spacing:.05em; transition:all .15s;
}
.enh-use-btn:hover { background:rgba(138,47,201,.4); border-color:#8b2fc9; }
.enh-use-btn.btn-active {
  background:rgba(138,47,201,.6); border-color:#ce93d8;
  color:#fff; box-shadow:0 0 8px rgba(138,47,201,.5);
}
.enh-use-btn:disabled { opacity:.35; cursor:default; }

.log-box { flex:1; min-height:160px; overflow-y:auto; background:rgba(0,0,0,.45); border-radius:10px; border:1px solid rgba(255,255,255,.05); padding:9px; font-size:11px; line-height:1.85; color:rgba(190,220,190,.8); }
.log-ok  { color:#70ff90; }
.log-bad { color:#ff7070; }
.log-evt { color:#ffb74d; }
.log-inf { color:#90caf9; }
.log-ai  { color:#ce93d8; font-style:italic; }

/* ‚ïê‚ïê‚ïê DICE OVERLAY ‚ïê‚ïê‚ïê */
#dice-overlay { position:fixed; inset:0; background:rgba(0,0,0,.92); display:none; flex-direction:column; align-items:center; justify-content:center; gap:20px; z-index:200; }
#dice-overlay.show { display:flex; }
.dice-atk-lbl { font-size:13px; letter-spacing:.25em; color:var(--gold-dk); text-transform:uppercase; }
.dice-who { font-size:11px; color:rgba(255,255,255,.4); letter-spacing:.15em; }
.dice-row { display:flex; gap:10px; flex-wrap:wrap; justify-content:center; }
.die { width:62px; height:62px; background:var(--parch); border-radius:12px; display:flex; align-items:center; justify-content:center; font-size:26px; font-weight:bold; color:#1a1000; box-shadow:0 4px 18px rgba(0,0,0,.5); animation:dieIn .35s ease; }
.die.rerolled { background:var(--gold-lt); }
.dice-total   { font-size:20px; color:var(--gold-lt); text-align:center; }
.dice-needed  { font-size:14px; color:var(--parch-dk); }
.dice-outcome { font-size:32px; font-weight:bold; text-align:center; }
.dice-outcome.win  { color:#70ff90; }
.dice-outcome.lose { color:#ff6060; }
.dice-continue { padding:12px 30px; background:linear-gradient(180deg,var(--gold-lt),var(--gold)); border:none; border-radius:10px; font-family:inherit; font-size:14px; font-weight:bold; color:#1a0e00; cursor:pointer; letter-spacing:.1em; margin-top:6px; display:none; }
.dice-continue:hover { filter:brightness(1.1); }

/* ‚ïê‚ïê‚ïê GAME OVER ‚ïê‚ïê‚ïê */
#gameover-overlay { position:fixed; inset:0; background:rgba(0,0,0,.88); display:none; align-items:center; justify-content:center; z-index:300; }
#gameover-overlay.show { display:flex; }
.go-modal { background:linear-gradient(160deg,#1e3820,#0d1a0e); border:1px solid var(--gold-dk); border-radius:20px; padding:38px 46px; max-width:540px; width:92%; text-align:center; box-shadow:0 28px 90px rgba(0,0,0,.75); }
.go-modal h2 { font-size:28px; color:var(--gold-lt); margin-bottom:6px; }
.go-winner { font-size:16px; color:#80ff80; margin-bottom:26px; }
.go-table { width:100%; border-collapse:collapse; margin-bottom:18px; }
.go-table th { font-size:9px; letter-spacing:.2em; color:var(--gold-dk); text-transform:uppercase; padding:5px 8px; border-bottom:1px solid rgba(212,160,23,.2); text-align:left; }
.go-table td { padding:7px 8px; font-size:13px; border-bottom:1px solid rgba(255,255,255,.05); }
.go-table tr.w td { color:var(--gold-lt); font-weight:bold; }
.go-note { font-size:11px; color:rgba(255,255,255,.35); margin-bottom:24px; font-style:italic; }
.go-btn { padding:12px 28px; background:linear-gradient(180deg,var(--gold-lt),var(--gold)); border:none; border-radius:10px; font-family:inherit; font-size:13px; font-weight:bold; color:#1a0e00; cursor:pointer; letter-spacing:.1em; }
.go-btn:hover { filter:brightness(1.1); }

@keyframes pulseBorder { 0%,100%{border-color:#cc0000;box-shadow:0 0 8px rgba(200,0,0,.3);}50%{border-color:#ff4444;box-shadow:0 0 20px rgba(255,68,68,.5);} }
@keyframes dieIn { from{transform:scale(.3) rotate(0deg);opacity:0;} to{transform:scale(1) rotate(720deg);opacity:1;} }
::-webkit-scrollbar{width:5px;} ::-webkit-scrollbar-track{background:rgba(0,0,0,.2);} ::-webkit-scrollbar-thumb{background:rgba(212,160,23,.2);border-radius:4px;}
@media(max-width:720px){ .game-body{grid-template-columns:1fr;} .g-right{border-left:none;border-top:1px solid rgba(212,160,23,.12);max-height:280px;} .dw-card{width:118px;} }
</style>
</head>
<body>

<!-- SETUP -->
<div id="setup" class="screen active">
  <div class="logo">
    <span class="logo-icon">üêâ</span>
    <h1>DRAGONWOOD</h1>
    <p>A Game of Dice &amp; Daring</p>
  </div>
  <div class="setup-box">
    <h2>Begin Your Adventure</h2>
    <label class="field-lbl">Number of Adventurers</label>
    <div class="count-row">
      <button class="cnt-btn" id="cnt-dn">‚àí</button>
      <span id="cnt-display">2</span>
      <button class="cnt-btn" id="cnt-up">+</button>
      <span class="cnt-label">players</span>
    </div>
    <div class="name-fields" id="name-fields"></div>
    <button class="start-btn" id="start-btn">‚öî Enter the Forest</button>
  </div>
</div>

<!-- GAME -->
<div id="game" class="screen">
  <div class="topbar">
    <span class="tb-title">üêâ Dragonwood</span>
    <span class="tb-turn" id="tb-turn"></span>
    <span class="tb-decks" id="tb-decks"></span>
    <div class="score-chips" id="score-chips"></div>
  </div>
  <div class="game-body">
    <div class="g-left">
      <div>
        <div class="sec-lbl">üå≤ The Landscape</div>
        <div class="landscape-row" id="landscape-row"></div>
      </div>
      <div class="action-panel">
        <div class="sel-info" id="sel-info">Select cards from your hand, then choose an attack ‚Äî or Reload.</div>
        <div class="wound-banner" id="wound-banner">‚ö† WOUNDED ‚Äî Click a card from your hand to discard as a wound.</div>
        <div class="ai-thinking" id="ai-thinking">ü§ñ Thinking...</div>
        <div class="btn-row">
          <button class="btn btn-reload" id="btn-reload" onclick="doReload()"><span class="bi">üîÑ</span>Reload</button>
          <button class="btn btn-strike" id="btn-strike" onclick="doCapture('strike')"><span class="bi">‚öî</span>Strike<span class="bs">Consecutive</span></button>
          <button class="btn btn-stomp"  id="btn-stomp"  onclick="doCapture('stomp')"><span class="bi">üë¢</span>Stomp<span class="bs">Same Number</span></button>
          <button class="btn btn-scream" id="btn-scream" onclick="doCapture('scream')"><span class="bi">üò±</span>Scream<span class="bs">Same Suit</span></button>
          <button class="btn btn-clear" onclick="clearSel()"><span class="bi">‚úï</span>Clear</button>
        </div>
      </div>
      <div>
        <div class="hand-lbl" id="hand-lbl">Your Hand</div>
        <div class="hand-row" id="hand-row"></div>
      </div>
    </div>
    <div class="g-right">
      <div>
        <div class="rp-lbl">‚ú® Enhancements</div>
        <div id="enh-panel"></div>
      </div>
      <div style="flex:1;display:flex;flex-direction:column;min-height:0">
        <div class="rp-lbl">üìú Log</div>
        <div class="log-box" id="log-box"></div>
      </div>
    </div>
  </div>
</div>

<!-- DICE OVERLAY -->
<div id="dice-overlay">
  <div class="dice-who" id="dice-who"></div>
  <div class="dice-atk-lbl" id="dice-atk-lbl"></div>
  <div class="dice-row" id="dice-row"></div>
  <div class="dice-total"  id="dice-total"></div>
  <div class="dice-needed" id="dice-needed"></div>
  <div class="dice-outcome" id="dice-outcome"></div>
  <button class="dice-continue" id="dice-continue" onclick="closeDice()">Continue</button>
</div>

<!-- GAME OVER -->
<div id="gameover-overlay">
  <div class="go-modal">
    <h2>üêâ Game Over!</h2>
    <div class="go-winner" id="go-winner"></div>
    <table class="go-table">
      <thead><tr><th>Player</th><th>VP</th><th>Cards</th><th>Bonus</th><th>Total</th></tr></thead>
      <tbody id="go-tbody"></tbody>
    </table>
    <p class="go-note">+3 VP bonus to player with most captured cards (+2 if tied)</p>
    <button class="go-btn" onclick="resetToSetup()">üîÑ Play Again</button>
  </div>
</div>

<script>
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// CONSTANTS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const SUITS  = ['Moon','Leaf','Fire','Storm','Water'];
const SSYMS  = ['üåô','üåø','üî•','‚ö°','üíß'];
const DFACES = [1,2,2,3,3,4];

const CREATURES = [
  {name:'Crazy Bats',      vp:1, st:4,  sk:3,  sc:3,  n:4},
  {name:'Spooky Spiders',  vp:1, st:3,  sk:3,  sc:4,  n:4},
  {name:'Fire Ants',       vp:2, st:7,  sk:4,  sc:6,  n:2},
  {name:'Giggling Goblin', vp:2, st:7,  sk:5,  sc:5,  n:2},
  {name:"Wasps' Nest",     vp:2, st:5,  sk:6,  sc:7,  n:2},
  {name:'Fierce Jaguar',   vp:3, st:8,  sk:6,  sc:8,  n:2},
  {name:'Hungry Bear',     vp:3, st:7,  sk:6,  sc:9,  n:2},
  {name:'Pack of Wolves',  vp:3, st:6,  sk:7,  sc:9,  n:2},
  {name:'Wild Boar',       vp:3, st:8,  sk:7,  sc:7,  n:2},
  {name:'Gigantic Python', vp:4, st:11, sk:8,  sc:10, n:1},
  {name:'Grumpy Troll',    vp:4, st:9,  sk:11, sc:9,  n:1},
  {name:'Secret Shadow',   vp:4, st:10, sk:8,  sc:11, n:1},
  {name:'Gooey Glob',      vp:5, st:14, sk:9,  sc:10, n:1},
  {name:'Angry Ogre',      vp:5, st:12, sk:9,  sc:14, n:1},
  {name:'Blue Dragon',     vp:6, st:13, sk:10, sc:13, n:1, dragon:true},
  {name:'Orange Dragon',   vp:7, st:15, sk:11, sc:12, n:1, dragon:true},
];
const ENHANCEMENTS = [
  {name:'Friendly Bunny',   eff:'Roll 1 extra die in an attempt',  perm:false, strike:4,  stomp:4,  scream:4},
  {name:'Charmed Potion',   eff:'Use as any Adventurer card',       perm:false, strike:5,  stomp:4,  scream:5},
  {name:'Lightning Bolt',   eff:'Add 4 points to an attempt',       perm:false, strike:7,  stomp:5,  scream:7},
  {name:'Lucky Mushroom',   eff:'Re-roll 1 die in any attempt',     perm:true,  strike:7,  stomp:5,  scream:7},
  {name:'Magical Unicorn',  eff:'Add 1 point to all attempts',      perm:true,  strike:8,  stomp:6,  scream:8},
  {name:'Silver Sword',     eff:'+2 to all Strikes',                perm:true,  strike:10, stomp:6,  scream:7},
  {name:'Bucket of Spinach',eff:'+2 to all Stomps',                 perm:true,  strike:7,  stomp:10, scream:8},
  {name:'Ghost Disguise',   eff:'+2 to all Screams',                perm:true,  strike:8,  stomp:7,  scream:10},
  {name:'Cloak of Darkness',eff:'Add 2 points to all attempts',     perm:true,  strike:11, stomp:9,  scream:11},
];
const EVENTS = [
  {name:'Quicksand',    txt:'Remove all Enhancements from the Landscape.'},
  {name:'Sunny Day',    txt:'All players draw 2 Adventurer cards.'},
  {name:'Thunderstorm', txt:'All players discard 1 Adventurer card.'},
  {name:'Wind Storm',   txt:'All players pass 1 Adventurer card to the left.'},
];

// Enhancement perceived VP values for AI evaluation
const ENH_VP = {
  'Friendly Bunny':   1.5,
  'Charmed Potion':   1.0,
  'Lightning Bolt':   2.5,
  'Lucky Mushroom':   2.0,
  'Magical Unicorn':  2.5,
  'Silver Sword':     2.2,
  'Bucket of Spinach':2.2,
  'Ghost Disguise':   2.2,
  'Cloak of Darkness':3.5,
};

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// PROBABILITY ENGINE
// Exact distribution for 1‚Äì6 custom Dragonwood dice [1,2,2,3,3,4]
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const PROB_DIST = (() => {
  // dist[n] maps sum ‚Üí probability
  const dist = [{ 0: 1.0 }];
  for (let n = 1; n <= 6; n++) {
    const cur = {};
    for (const [s, p] of Object.entries(dist[n - 1])) {
      for (const f of DFACES) {
        const ns = (+s) + f;
        cur[ns] = (cur[ns] || 0) + p / 6;
      }
    }
    dist.push(cur);
  }
  return dist;
})();

function pAtLeast(n, k) {
  // P(sum of n dice >= k), exact
  if (n <= 0) return k <= 0 ? 1 : 0;
  if (k <= n)   return 1.0;   // minimum roll is n (all 1s)
  if (k > 4 * n) return 0.0;  // maximum roll is 4n
  let p = 0;
  for (const [s, pr] of Object.entries(PROB_DIST[n])) {
    if (+s >= k) p += pr;
  }
  return p;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// GAME STATE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
let G = null;
let sel = [];
let targetIdx = null;
let woundMode = false;
let pendingDice = null;
let logs = [];
let uid = 0;
let aiTimer = null;
let activeOneTimeIds = new Set();
const ID = () => ++uid;

function shuffle(a) {
  const b = [...a];
  for (let i = b.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [b[i], b[j]] = [b[j], b[i]];
  }
  return b;
}

function mkAdvDeck() {
  const d = [];
  for (let s = 0; s < 5; s++) for (let n = 1; n <= 12; n++) d.push({ id: ID(), suit: s, num: n, lb: false });
  for (let i = 0; i < 4; i++) d.push({ id: ID(), suit: 0, num: 0, lb: true });
  return shuffle(d);
}

function mkDWDeck() {
  const d = [];
  CREATURES.forEach(c => {
    for (let i = 0; i < c.n; i++)
      d.push({ id: ID(), type: 'creature', name: c.name, vp: c.vp, strike: c.st, stomp: c.sk, scream: c.sc, dragon: !!c.dragon });
  });
  ENHANCEMENTS.forEach(e =>
    d.push({ id: ID(), type: 'enhancement', name: e.name, eff: e.eff, perm: e.perm, used: false, strike: e.strike, stomp: e.stomp, scream: e.scream }));
  EVENTS.forEach(e => d.push({ id: ID(), type: 'event', name: e.name, txt: e.txt }));
  return d;
}

function startGame(names, aiFlags) {
  const n = names.length;
  const remove = { 2: 12, 3: 10, 4: 8 }[n] || 10;
  let full = mkDWDeck();
  const dragons = full.filter(c => c.dragon);
  let rest = shuffle(full.filter(c => !c.dragon)).slice(remove);
  const mid = Math.floor(rest.length / 2);
  const dwDeck = [...rest.slice(0, mid), ...shuffle([...rest.slice(mid), ...dragons])];

  G = {
    players: names.map((nm, i) => ({ name: nm, hand: [], captured: [], enhancements: [], isAI: !!aiFlags[i] })),
    cur: 0,
    advDeck: mkAdvDeck(),
    advDiscard: [],
    advDecksUsed: 0,
    dwDeck,
    landscape: [],
    over: false,
  };

  G.players.forEach(p => { for (let i = 0; i < 5; i++) deal(p); });
  fillLandscape();
  sel = []; targetIdx = null; woundMode = false; pendingDice = null; logs = [];
  log('üêâ The adventure begins! Good luck, adventurers.', 'inf');
}

function deal(player) {
  if (!G.advDeck.length) {
    if (!G.advDiscard.length) return;
    G.advDeck = shuffle(G.advDiscard);
    G.advDiscard = [];
    G.advDecksUsed++;
    log(`üìö Adventurer deck reshuffled (${G.advDecksUsed}/2).`, 'inf');
    if (G.advDecksUsed >= 2) { log('‚ö† Two adventure decks used! Final round.', 'evt'); G.over = true; }
  }
  const c = G.advDeck.pop();
  if (c.lb) {
    G.advDiscard.push(c);
    log(`üêû Lucky Ladybug! ${player.name} draws 2 extra cards.`, 'inf');
    deal(player); deal(player);
  } else {
    player.hand.push(c);
  }
}

function fillLandscape() {
  while (G.landscape.filter(Boolean).length < 5 && G.dwDeck.length > 0) {
    const c = G.dwDeck.shift();
    if (c.type === 'event') runEvent(c);
    else G.landscape.push(c);
  }
}

function runEvent(c) {
  log(`‚ö° EVENT: ${c.name} ‚Äî ${c.txt}`, 'evt');
  if (c.name === 'Sunny Day') {
    G.players.forEach(p => { deal(p); deal(p); });
  } else if (c.name === 'Thunderstorm') {
    G.players.forEach(p => {
      if (p.hand.length) { const i = Math.floor(Math.random() * p.hand.length); G.advDiscard.push(...p.hand.splice(i, 1)); }
    });
  } else if (c.name === 'Quicksand') {
    const rm = G.landscape.filter(x => x && x.type === 'enhancement');
    G.landscape = G.landscape.filter(x => x && x.type !== 'enhancement');
    if (rm.length) log(`  ${rm.length} enhancement(s) swept from Landscape.`);
  } else if (c.name === 'Wind Storm') {
    const np = G.players.length;
    if (G.players.every(p => p.hand.length > 0)) {
      const passed = G.players.map(p => p.hand.splice(Math.floor(Math.random() * p.hand.length), 1)[0]);
      G.players.forEach((p, i) => p.hand.push(passed[(i - 1 + np) % np]));
      log('  Each player passed 1 card to the left.');
    }
  }
}

function log(msg, cls = '') { logs.push({ msg, cls }); if (logs.length > 80) logs.shift(); }

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// PLAYER ACTIONS (human)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function isAITurn() { return G && G.players[G.cur].isAI; }

function doReload() {
  if (woundMode || G.over || isAITurn()) return;
  const p = G.players[G.cur];
  if (p.hand.length >= 9) { log('‚ö† Hand full (9 cards)!', 'bad'); render(); return; }
  clearSel();
  deal(p);
  log(`${p.name} reloads.`);
  nextTurn();
  render();
}

function doCapture(type) {
  if (woundMode || G.over || isAITurn()) return;
  if (!sel.length) { log('‚ö† Select cards from your hand first!', 'bad'); render(); return; }
  if (targetIdx === null) { log('‚ö† Click a Landscape card to target it!', 'bad'); render(); return; }
  const tgt = G.landscape[targetIdx];
  if (!tgt) { log('‚ö† Target gone.', 'bad'); targetIdx = null; render(); return; }
  const p = G.players[G.cur];
  const cards = p.hand.filter(c => sel.includes(c.id));
  const v = validate(cards, type);
  if (!v.ok) { log(`‚ö† Invalid ${type}: ${v.why}`, 'bad'); render(); return; }
  _executeAttack(p, cards, type, tgt, targetIdx);
}

function _executeAttack(p, cards, type, tgt, tidx) {
  // For human players: one-time enhancements only fire if manually toggled ON.
  // For AI: all available one-time enhancements fire automatically.
  const isHuman = !p.isAI;
  const oneTimeActive = e => !e.perm && !e.used && (p.isAI || activeOneTimeIds.has(e.id));

  let numDice = cards.length;
  // Friendly Bunny / Charmed Potion: +1 die each if active
  if (p.enhancements.some(e => (e.name === 'Friendly Bunny' || e.name === 'Charmed Potion') && oneTimeActive(e))) numDice++;
  numDice = Math.min(numDice, 6);

  const rolls = Array.from({ length: numDice }, () => DFACES[Math.floor(Math.random() * 6)]);

  // Lucky Mushroom (permanent): always re-rolls lowest die
  let rerolled = null;
  if (p.enhancements.some(e => e.name === 'Lucky Mushroom' && !e.used) && rolls.length > 0) {
    const wi = rolls.indexOf(Math.min(...rolls));
    const nr = DFACES[Math.floor(Math.random() * 6)];
    rerolled = { i: wi, old: rolls[wi], nw: nr };
    rolls[wi] = nr;
  }

  const total = rolls.reduce((a, b) => a + b, 0);
  const bonus = calcBonus(p, type);
  const final = total + bonus;
  const req   = tgt[type];
  const win   = final >= req;

  // Only mark one-time enhancements as used if they were actually activated
  p.enhancements.forEach(e => { if (oneTimeActive(e)) e.used = true; });
  activeOneTimeIds = new Set();

  pendingDice = { type, rolls, rerolled, total, bonus, final, req, tgt, p, win, cards, tidx };
  showDice();
}

function calcBonus(p, type) {
  let b = 0;
  p.enhancements.forEach(e => {
    if (e.used) return;
    // One-time enhancements: only apply if toggled on (or AI)
    const oneTimeOn = !e.perm ? (p.isAI || activeOneTimeIds.has(e.id)) : true;
    if (!oneTimeOn) return;
    const ef = e.eff.toLowerCase();
    if (ef.includes('add 4'))                                     b += 4;  // Lightning Bolt (one-time)
    else if (e.name === 'Cloak of Darkness')                      b += 2;  // permanent
    else if (ef.includes('add 2 points to all'))                  b += 2;  // permanent
    else if (ef.includes('add 1 point to all'))                   b += 1;  // permanent
    else if (ef.includes('+2 to all strikes') && type==='strike') b += 2;  // permanent
    else if (ef.includes('+2 to all stomps')  && type==='stomp')  b += 2;  // permanent
    else if (ef.includes('+2 to all screams') && type==='scream') b += 2;  // permanent
  });
  return b;
}

function validate(cards, type) {
  if (!cards.length) return { ok: false, why: 'No cards selected' };
  if (cards.length > 6) return { ok: false, why: 'Max 6 cards' };
  if (cards.length === 1) return { ok: true };
  if (type === 'strike') {
    const ns = cards.map(c => c.num).sort((a, b) => a - b);
    for (let i = 1; i < ns.length; i++) if (ns[i] !== ns[i - 1] + 1) return { ok: false, why: `Consecutive required: ${ns.join(',')}` };
  } else if (type === 'stomp') {
    if (new Set(cards.map(c => c.num)).size !== 1) return { ok: false, why: `Same number required: ${cards.map(c => c.num).join(',')}` };
  } else if (type === 'scream') {
    if (new Set(cards.map(c => c.suit)).size !== 1) return { ok: false, why: `Same suit required: ${cards.map(c => SUITS[c.suit]).join(',')}` };
  }
  return { ok: true };
}

function applyResult() {
  const d = pendingDice;
  if (!d) return;
  const p = d.p;

  if (d.win) {
    d.cards.forEach(c => {
      const i = p.hand.findIndex(h => h.id === c.id);
      if (i !== -1) G.advDiscard.push(p.hand.splice(i, 1)[0]);
    });
    if (d.tgt.type === 'creature') {
      p.captured.push(d.tgt);
      log(`‚úÖ ${p.name} captured ${d.tgt.name}! (+${d.tgt.vp} VP)`, 'ok');
    } else {
      p.enhancements.push(d.tgt);
      log(`‚úÖ ${p.name} obtained ${d.tgt.name}!`, 'ok');
    }
    G.landscape.splice(d.tidx, 1);
    fillLandscape();
    checkOver();
    clearSel();
    if (!G.over) nextTurn();
  } else {
    log(`‚ùå ${p.name}'s attack failed! Must discard a wound card.`, 'bad');
    clearSel();
    woundMode = true;
    // AI auto-handles wound
    if (p.isAI) {
      render();
      aiTimer = setTimeout(aiHandleWound, 900);
      pendingDice = null;
      return;
    }
  }

  pendingDice = null;
  render();
  if (G.over) showGameOver();
}

function discardWound(cid) {
  if (!woundMode) return;
  const p = G.players[G.cur];
  const i = p.hand.findIndex(c => c.id === cid);
  if (i === -1) return;
  G.advDiscard.push(p.hand.splice(i, 1)[0]);
  woundMode = false;
  nextTurn();
  render();
}

function checkOver() {
  const all = G.players.flatMap(p => p.captured);
  const hasBlue   = all.some(c => c.name === 'Blue Dragon');
  const hasOrange = all.some(c => c.name === 'Orange Dragon');
  if (hasBlue && hasOrange) { log('üêâ Both dragons slain! The forest is saved!', 'ok'); G.over = true; }
}

function nextTurn() {
  if (!G.over) {
    G.cur = (G.cur + 1) % G.players.length;
    log(`‚Äî ${G.players[G.cur].name}'s turn ‚Äî`);
    if (G.players[G.cur].isAI) {
      render();
      scheduleAI(1100);
    }
  }
}

function clearSel() { sel = []; targetIdx = null; activeOneTimeIds = new Set(); }

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// AI ENGINE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function scheduleAI(ms) {
  if (aiTimer) clearTimeout(aiTimer);
  showAIThinking(true);
  aiTimer = setTimeout(() => { showAIThinking(false); aiTakeTurn(); }, ms);
}

function showAIThinking(on) {
  const el = document.getElementById('ai-thinking');
  if (el) el.classList.toggle('show', on);
}

// ‚îÄ‚îÄ Combo finders ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function bestStrike(hand) {
  // Find longest consecutive run (each number used once, max 6 cards)
  const byNum = {};
  hand.forEach(c => { if (!byNum[c.num]) byNum[c.num] = c; });
  const nums = Object.keys(byNum).map(Number).sort((a, b) => a - b);

  let best = [], cur = [];
  for (const n of nums) {
    if (!cur.length || n === cur[cur.length - 1] + 1) cur.push(n);
    else { if (cur.length > best.length) best = [...cur]; cur = [n]; }
  }
  if (cur.length > best.length) best = cur;
  if (best.length > 6) best = best.slice(0, 6);
  return best.map(n => byNum[n]);
}

function bestStomp(hand) {
  // Largest same-number group
  const g = {};
  hand.forEach(c => { if (!g[c.num]) g[c.num] = []; g[c.num].push(c); });
  const arr = Object.values(g).sort((a, b) => b.length - a.length);
  return (arr[0] || []).slice(0, 6);
}

function bestScream(hand) {
  // Largest same-suit group
  const g = {};
  hand.forEach(c => { if (!g[c.suit]) g[c.suit] = []; g[c.suit].push(c); });
  const arr = Object.values(g).sort((a, b) => b.length - a.length);
  return (arr[0] || []).slice(0, 6);
}

// ‚îÄ‚îÄ Card value for AI ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function cardTargetValue(card, player) {
  if (card.type === 'creature') {
    let v = card.vp;
    if (card.dragon) v += 9; // dragons are game-critical
    return v;
  }
  // Enhancement - already owned by someone else?
  return ENH_VP[card.name] || 1.5;
}

// ‚îÄ‚îÄ Score gap pressure: AI takes more risk if losing ‚îÄ‚îÄ
function pressureFactor(player) {
  const myVP = player.captured.reduce((s, c) => s + c.vp, 0);
  const bestOpp = G.players.filter(p => p !== player).reduce((best, op) => {
    return Math.max(best, op.captured.reduce((s, c) => s + c.vp, 0));
  }, 0);
  const gap = bestOpp - myVP;
  if (gap >= 7) return 1.4;  // desperate ‚Äî attack even with lower odds
  if (gap >= 4) return 1.2;
  if (gap >= 2) return 1.1;
  return 1.0;
}

// ‚îÄ‚îÄ Main AI decision ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function aiDecide(player) {
  const pressure = pressureFactor(player);
  const handSize = player.hand.length;
  const options = [];

  // Build best combos once ‚Äî same combo type applies to all targets
  const combos = {
    strike: bestStrike(player.hand),
    stomp:  bestStomp(player.hand),
    scream: bestScream(player.hand),
  };

  G.landscape.forEach((card, idx) => {
    if (!card) return;
    const val = cardTargetValue(card, player);

    for (const [type, combo] of Object.entries(combos)) {
      if (!combo.length) continue;
      if (!validate(combo, type).ok) continue;

      let nd = Math.min(combo.length, 6);
      if (player.enhancements.some(e => e.name === 'Friendly Bunny' && !e.used)) nd = Math.min(nd + 1, 6);

      const bonus = calcBonus(player, type);
      const req   = card[type];
      const effectiveReq = Math.max(1, req - bonus);
      const prob  = pAtLeast(nd, effectiveReq);

      // Minimum probability thresholds ‚Äî AI won't gamble recklessly
      const minProb = card.dragon ? 0.18 : 0.35;
      if (prob < minProb / pressure) continue;

      // Wound cost is significant: losing a hand card slows future attacks
      // Higher cost = AI avoids risky attacks more appropriately
      const WOUND_COST = 1.0;
      const ev = val * prob * pressure - WOUND_COST * (1 - prob);

      options.push({ card, idx, type, combo, prob, ev, val, req, nd, bonus });
    }
  });

  options.sort((a, b) => b.ev - a.ev);
  const best = options[0];

  // ‚îÄ‚îÄ How much would ONE more card improve the best attack? ‚îÄ‚îÄ
  // If reloading could push combo from k to k+1 dice, that extra die has value.
  let comboImprovementVal = 0;
  if (best && best.nd < 6) {
    const improvedProb = pAtLeast(Math.min(best.nd + 1, 6), Math.max(1, best.req - best.bonus));
    const probGain = improvedProb - best.prob;
    // Weight by ~60% chance reload actually gives the right card type
    comboImprovementVal = probGain * best.val * 0.6;
  }

  // ‚îÄ‚îÄ Reload value thresholds ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // A small hand should almost always reload ‚Äî bigger combos = much better odds.
  // These values represent the minimum EV an attack must beat to be worth doing NOW
  // rather than building a better hand first.
  const baseReloadVal =
      handSize <= 3 ? 2.8   // tiny hand: only attack if it's basically guaranteed
    : handSize <= 4 ? 1.8   // small hand: need a very good opportunity
    : handSize <= 5 ? 1.1   // medium hand: attack if EV is clearly positive
    : handSize <= 7 ? 0.55  // good hand: attack unless marginal
    :                 0.15; // large hand: almost always attack

  const reloadVal = baseReloadVal + comboImprovementVal;

  // Force attack if hand is full (no choice)
  if (handSize >= 9 && best) return { action: 'attack', ...best };

  // Reload if no viable attack or best EV below reload threshold
  if (!best || best.ev < reloadVal) return { action: 'reload' };

  return { action: 'attack', ...best };
}

// ‚îÄ‚îÄ Wound card: discard the least useful card ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function worstCard(hand) {
  // Score each card by how many others it combos with (higher = more valuable)
  function synergyScore(c) {
    const suitMates  = hand.filter(x => x.suit === c.suit).length - 1;
    const numMates   = hand.filter(x => x.num === c.num).length - 1;
    // Count how long a consecutive run c participates in
    const nums = hand.map(x => x.num).sort((a, b) => a - b);
    let runLen = 1;
    for (let i = 0; i < nums.length - 1; i++) {
      if (nums[i] === c.num || (nums[i] >= c.num - 3 && nums[i + 1] === nums[i] + 1)) runLen++;
    }
    return Math.max(suitMates, numMates, runLen - 1);
  }
  return hand.reduce((worst, c) => synergyScore(c) < synergyScore(worst) ? c : worst, hand[0]);
}

// ‚îÄ‚îÄ Execute AI turn ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function aiTakeTurn() {
  if (G.over) return;
  const p = G.players[G.cur];
  if (!p.isAI) return;

  const decision = aiDecide(p);

  if (decision.action === 'reload') {
    log(`ü§ñ ${p.name} reloads ‚Äî hand not ready.`, 'ai');
    deal(p);
    nextTurn();
    render();
    return;
  }

  // Attack
  const { type, combo, card, idx, prob } = decision;
  const typeWord = { strike: 'Strikes', stomp: 'Stomps', scream: 'Screams' }[type];
  log(`ü§ñ ${p.name} ${typeWord} at ${card.name} (${Math.round(prob * 100)}% chance)`, 'ai');

  // Highlight AI's target briefly, then attack
  sel = combo.map(c => c.id);
  targetIdx = idx;
  render();

  aiTimer = setTimeout(() => {
    _executeAttack(p, combo, type, card, idx);
  }, 600);
}

// ‚îÄ‚îÄ Auto-handle wound ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function aiHandleWound() {
  if (!woundMode) return;
  const p = G.players[G.cur];
  if (!p.hand.length) { woundMode = false; nextTurn(); render(); return; }
  const card = worstCard(p.hand);
  log(`ü§ñ ${p.name} discards ${SSYMS[card.suit]}${SUITS[card.suit]}-${card.num} as a wound.`, 'ai');
  G.advDiscard.push(...p.hand.splice(p.hand.indexOf(card), 1));
  woundMode = false;
  nextTurn();
  render();
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// DICE OVERLAY
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
let diceAutoClose = null;

function showDice() {
  const d = pendingDice;
  const labels = { strike: '‚öî Strike', stomp: 'üë¢ Stomp', scream: 'üò± Scream' };
  const whoEl   = document.getElementById('dice-who');
  const lbl     = document.getElementById('dice-atk-lbl');
  const row     = document.getElementById('dice-row');
  const totEl   = document.getElementById('dice-total');
  const nedEl   = document.getElementById('dice-needed');
  const outEl   = document.getElementById('dice-outcome');
  const contBtn = document.getElementById('dice-continue');

  whoEl.textContent   = d.p.isAI ? `ü§ñ ${d.p.name}` : `üë§ ${d.p.name}`;
  lbl.textContent     = `${labels[d.type]} vs ${d.tgt.name}`;
  row.innerHTML       = '';
  contBtn.style.display = 'none';
  totEl.textContent   = '';
  nedEl.textContent   = '';
  outEl.textContent   = '';
  outEl.className     = 'dice-outcome';

  document.getElementById('dice-overlay').classList.add('show');

  let delay = 0;
  d.rolls.forEach((v, i) => {
    setTimeout(() => {
      const el = document.createElement('div');
      el.className = 'die' + (d.rerolled && d.rerolled.i === i ? ' rerolled' : '');
      el.textContent = v;
      if (d.rerolled && d.rerolled.i === i) el.title = `Re-rolled (was ${d.rerolled.old})`;
      row.appendChild(el);

      if (i === d.rolls.length - 1) {
        setTimeout(() => {
          totEl.textContent = d.bonus
            ? `${d.total} + ${d.bonus} bonus = ${d.final}`
            : `Total: ${d.final}`;
          nedEl.textContent = `Needed: ${d.req} to ${d.type}`;
          setTimeout(() => {
            if (d.win) { outEl.textContent = `‚úÖ Captured ${d.tgt.name}!`; outEl.classList.add('win'); }
            else        { outEl.textContent = `‚ùå Failed (${d.final} < ${d.req})`;  outEl.classList.add('lose'); }
            contBtn.style.display = 'inline-block';
            // Auto-close after 2s if it's an AI's turn
            if (d.p.isAI) {
              diceAutoClose = setTimeout(closeDice, 2000);
            }
          }, 350);
        }, 250);
      }
    }, delay);
    delay += 140;
  });
}

function closeDice() {
  if (diceAutoClose) { clearTimeout(diceAutoClose); diceAutoClose = null; }
  document.getElementById('dice-overlay').classList.remove('show');
  applyResult();
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// GAME OVER
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function showGameOver() {
  const scores = G.players.map(p => ({
    name:   p.name,
    isAI:   p.isAI,
    base:   p.captured.reduce((s, c) => s + c.vp, 0),
    cards:  p.captured.length,
    orange: p.captured.some(c => c.name === 'Orange Dragon'),
  }));
  const maxCards = Math.max(...scores.map(s => s.cards));
  const top = scores.filter(s => s.cards === maxCards);
  const bonus = top.length === 1 ? 3 : 2;
  scores.forEach(s => { s.bonus = s.cards === maxCards ? bonus : 0; s.total = s.base + s.bonus; });
  scores.sort((a, b) => b.total - a.total || (b.orange ? 1 : -1));

  const w = scores[0];
  document.getElementById('go-winner').textContent = `üèÜ ${w.isAI ? 'ü§ñ' : 'üë§'} ${w.name} wins with ${w.total} Victory Points!`;
  const tb = document.getElementById('go-tbody');
  tb.innerHTML = '';
  scores.forEach((s, i) => {
    const tr = document.createElement('tr');
    if (i === 0) tr.className = 'w';
    tr.innerHTML = `<td>${i === 0 ? 'üëë ' : ''}${s.isAI ? 'ü§ñ ' : ''}${s.name}</td><td>${s.base}</td><td>${s.cards}</td><td>${s.bonus > 0 ? '+' + s.bonus : '‚Äî'}</td><td>${s.total}</td>`;
    tb.appendChild(tr);
  });
  document.getElementById('gameover-overlay').classList.add('show');
}

function resetToSetup() {
  if (aiTimer) clearTimeout(aiTimer);
  document.getElementById('gameover-overlay').classList.remove('show');
  document.getElementById('game').classList.remove('active');
  document.getElementById('setup').classList.add('active');
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// RENDER
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function render() {
  if (!G) return;
  const p = G.players[G.cur];
  const isAI = p.isAI;

  // Topbar
  const tb = document.getElementById('tb-turn');
  if (woundMode)      { tb.textContent = `‚ö† ${p.name} must discard a wound card`;       tb.className = 'tb-turn wound-turn'; }
  else if (isAI)      { tb.textContent = `ü§ñ ${p.name} is thinking...`;                  tb.className = 'tb-turn ai-turn'; }
  else                { tb.textContent = `üë§ ${p.name}'s Turn`;                           tb.className = 'tb-turn'; }

  document.getElementById('tb-decks').textContent = `üÉè ${G.dwDeck.length} left  |  üìö Decks: ${G.advDecksUsed}/2`;

  document.getElementById('score-chips').innerHTML = G.players.map((pl, i) => {
    const vp = pl.captured.reduce((s, c) => s + c.vp, 0);
    const ai = pl.isAI ? ' ai-chip' : '';
    const act = i === G.cur ? ' active' : '';
    return `<span class="chip${ai}${act}">${pl.isAI ? 'ü§ñ' : 'üë§'} ${pl.name}: ${vp} VP</span>`;
  }).join('');

  renderLandscape();
  renderSelInfo(p);
  document.getElementById('wound-banner').classList.toggle('show', woundMode && !isAI);

  document.getElementById('hand-lbl').textContent = `${p.name}'s Hand (${p.hand.length}/9)`;
  renderHand(p);
  renderEnh();

  const lb = document.getElementById('log-box');
  lb.innerHTML = logs.slice(-30).map(({ msg, cls }) =>
    `<div class="log-entry${cls ? ' log-' + cls : ''}">${escH(msg)}</div>`
  ).join('');
  lb.scrollTop = lb.scrollHeight;
}

function escH(s) { return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

function renderLandscape() {
  const row = document.getElementById('landscape-row');
  row.innerHTML = '';
  G.landscape.forEach((c, i) => {
    if (!c) return;
    const div = document.createElement('div');
    const isAI  = isAITurn();
    const aiEye = isAI && targetIdx === i;
    div.className = `dw-card ${c.type === 'creature' ? 'creature' : 'enhance'}${i === targetIdx ? (isAI ? ' ai-eyeing' : ' targeted') : ''}`;

    const atkGrid = `
      <div class="c-divider"></div>
      <div class="attack-grid">
        <div class="atk-row atk-strike"><span class="atk-lbl">‚öî Strike</span><span class="atk-num">${c.strike}</span></div>
        <div class="atk-row atk-stomp"> <span class="atk-lbl">üë¢ Stomp</span> <span class="atk-num">${c.stomp}</span></div>
        <div class="atk-row atk-scream"><span class="atk-lbl">üò± Scream</span><span class="atk-num">${c.scream}</span></div>
      </div>`;

    if (c.type === 'creature') {
      div.innerHTML = `<div class="c-badge">Creature</div><div class="c-name">${escH(c.name)}</div><div class="c-vp">üèÜ ${c.vp} VP</div>${atkGrid}`;
    } else {
      div.innerHTML = `<div class="c-badge">Enhancement</div><div class="c-name">${escH(c.name)}</div><div class="c-perm">${c.perm ? '‚òÖ Permanent' : '‚óÜ One-time'}</div><div class="c-effect">${escH(c.eff)}</div>${atkGrid}`;
    }

    div.addEventListener('click', () => {
      if (woundMode || isAITurn()) return;
      targetIdx = (targetIdx === i) ? null : i;
      render();
    });
    row.appendChild(div);
  });
}

function renderHand(p) {
  const row = document.getElementById('hand-row');
  row.innerHTML = '';
  p.hand.forEach(c => {
    const div = document.createElement('div');
    div.className = `adv-card s${c.suit}${sel.includes(c.id) ? ' selected' : ''}${woundMode && !p.isAI ? ' in-wound' : ''}`;
    div.innerHTML = `<div class="adv-num">${c.num}</div><div class="adv-suit">${SSYMS[c.suit]} ${SUITS[c.suit]}</div>`;
    div.addEventListener('click', () => {
      if (isAITurn()) return;
      if (woundMode) { discardWound(c.id); return; }
      const i = sel.indexOf(c.id);
      if (i !== -1) sel.splice(i, 1);
      else if (sel.length < 6) sel.push(c.id);
      render();
    });
    row.appendChild(div);
  });
}

function renderSelInfo(p) {
  const el = document.getElementById('sel-info');
  if (p.isAI) { el.textContent = 'ü§ñ AI is deciding...'; return; }
  if (woundMode) { el.innerHTML = '<span style="color:#ff8888">‚ö† Click a card to discard as a wound.</span>'; return; }
  if (!sel.length) { el.textContent = 'Select cards from your hand, then choose an attack ‚Äî or Reload.'; return; }
  const cards = p.hand.filter(c => sel.includes(c.id));
  const cardStr = cards.map(c => `${SSYMS[c.suit]}<b>${c.num}</b>`).join(' ');
  const tgt = targetIdx !== null ? G.landscape[targetIdx] : null;
  const tgtStr = tgt ? ` ‚Üí targeting <b>${escH(tgt.name)}</b>` : ' ‚Üí click a Landscape card to target';
  el.innerHTML = cardStr + tgtStr;
}

function renderEnh() {
  const el = document.getElementById('enh-panel');
  el.innerHTML = '';
  let any = false;
  const curPlayer = G.players[G.cur];

  G.players.forEach(p => {
    if (!p.enhancements.length) return;
    any = true;

    const ownerDiv = document.createElement('div');
    ownerDiv.className = 'enh-owner';
    ownerDiv.textContent = (p.isAI ? 'ü§ñ ' : '') + p.name;
    el.appendChild(ownerDiv);

    p.enhancements.forEach(e => {
      const item = document.createElement('div');
      item.className = 'enh-item' + (e.used ? ' used' : '');

      const isCurrentHumanPlayer = p === curPlayer && !p.isAI;
      const isToggleable = isCurrentHumanPlayer && !e.perm && !e.used && !woundMode;
      const isOn = activeOneTimeIds.has(e.id);

      item.innerHTML = `
        <div class="enh-name">${escH(e.name)}${e.used ? ' <span style="opacity:.5">(spent)</span>' : ''}</div>
        <div class="enh-eff">${escH(e.eff)}</div>
        <div class="enh-tag">${e.perm ? '‚òÖ Permanent ‚Äî always active' : '‚óÜ One-time use'}</div>
      `;

      // Add toggle button for usable one-time enhancements
      if (isToggleable) {
        const btn = document.createElement('button');
        btn.className = 'enh-use-btn' + (isOn ? ' btn-active' : '');
        btn.textContent = isOn ? '‚úì Active for next attack' : '+ Use on next attack';
        btn.addEventListener('click', () => {
          if (activeOneTimeIds.has(e.id)) activeOneTimeIds.delete(e.id);
          else activeOneTimeIds.add(e.id);
          render();
        });
        item.appendChild(btn);
      }

      el.appendChild(item);
    });
  });

  if (!any) el.innerHTML = '<div class="no-enh">No enhancements yet</div>';
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// SETUP UI
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
let numP = 2;
const DEF_NAMES  = ['You', 'Dragon AI', 'Player 3', 'Player 4'];
const DEF_IS_AI  = [false, true, false, false];

function updateSetup() {
  document.getElementById('cnt-display').textContent = numP;
  const nf = document.getElementById('name-fields');
  nf.innerHTML = '';
  for (let i = 0; i < numP; i++) {
    const row = document.createElement('div');
    row.className = 'name-row';

    const lbl = document.createElement('label');
    lbl.textContent = `Player ${i + 1}`;
    lbl.setAttribute('for', `n${i}`);

    const inp = document.createElement('input');
    inp.className = 'name-input'; inp.id = `n${i}`;
    inp.value = DEF_NAMES[i]; inp.maxLength = 18;

    const tog = document.createElement('label');
    tog.className = 'ai-toggle' + (DEF_IS_AI[i] ? ' checked' : '');
    tog.id = `aitog-${i}`;
    tog.innerHTML = `<input type="checkbox" id="ai${i}"${DEF_IS_AI[i] ? ' checked' : ''}><span class="ai-dot"></span> AI`;
    tog.querySelector('input').addEventListener('change', function () {
      tog.classList.toggle('checked', this.checked);
    });

    row.appendChild(lbl); row.appendChild(inp); row.appendChild(tog);
    nf.appendChild(row);
  }
}

document.getElementById('cnt-dn').addEventListener('click', () => { if (numP > 2) { numP--; updateSetup(); } });
document.getElementById('cnt-up').addEventListener('click', () => { if (numP < 4) { numP++; updateSetup(); } });

document.getElementById('start-btn').addEventListener('click', () => {
  const names = [], aiFlags = [];
  for (let i = 0; i < numP; i++) {
    const v = (document.getElementById(`n${i}`).value || '').trim() || `Player ${i + 1}`;
    const ai = document.getElementById(`ai${i}`).checked;
    names.push(v); aiFlags.push(ai);
  }
  if (aiTimer) clearTimeout(aiTimer);
  startGame(names, aiFlags);
  document.getElementById('setup').classList.remove('active');
  document.getElementById('game').classList.add('active');
  render();
  // Kick off AI if it goes first
  if (G.players[G.cur].isAI) scheduleAI(1200);
});

updateSetup();
</script>
</body>
</html>
